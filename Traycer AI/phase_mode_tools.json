{
  "read_file": {
    "description": "読み取ります the contents of ファイル at the specified パス. Use this when you need to examine the contents of any existing ファイル, for 例 to 分析します code, review text ファイル, or 抽出します information from configuration ファイル. For large ファイル, the system will provide a structured summary with line ranges and brief descriptions of each section instead of the full content. You can then request specific line ranges after reviewing the summary using the read_partial_file ツール. Automatically 抽出します raw text from PDF and DOCX ファイル. May not be suitable for other types of binary ファイル, as it 返します the raw content as a string. It is always better to speculatively 読み取ります multiple ファイル as a batch that are potentially useful.",
    "parameters": {
      "paths": {
        "description": "The パス of the ファイル to 読み取ります. Use absolute パス.",
        "items": {
          "properties": {
            "includeDiagnostics": {
              "default": false,
              "description": "Whether to collect diagnostics including エラー, 警告, and lint suggestions, by analyzing its code using the built-in LSP. 返します true only when you need to identify and resolve specific Issue.",
              "type": "boolean"
            },
            "path": {
              "sanitizePath": true,
              "type": "string"
            }
          },
          "required": [
            "path",
            "includeDiagnostics"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  },
  "read_partial_file": {
    "description": "読み取ります specific line ranges from ファイル at the specified パス. Use this when you need to examine only portions of ファイル rather than their entire contents, which is useful for when you only need to focus on specific sections of code, configuration ファイル, or text documents. Specify the startLine and numberOfLines properties for each パス to control exactly which portion of the ファイル you want to 読み取ります. This is more efficient than reading entire ファイル when you only need specific sections.",
    "parameters": {
      "paths": {
        "description": "The パス of the ファイル to 読み取ります. Each item is an object with パス and optional startLine and endLine properties to specify line ranges.",
        "items": {
          "properties": {
            "includeDiagnostics": {
              "default": false,
              "description": "Whether to collect diagnostics including エラー, 警告, and lint suggestions, by analyzing its code using the built-in LSP. 返します true only when you need to identify and resolve specific Issue.",
              "type": "boolean"
            },
            "numberOfLines": {
              "description": "The number of lines to 読み取ります from the start line. Allowed values are 300, 500, 700, or 900",
              "type": "number"
            },
            "path": {
              "description": "パス of the ファイル to 読み取ります. Use absolute パス.",
              "sanitizePath": true,
              "type": "string"
            },
            "startLine": {
              "description": "The starting line number to 読み取ります from (1-indexed). Optional - if omitted, starts from line 1.",
              "type": "number"
            }
          },
          "required": [
            "path",
            "numberOfLines",
            "startLine",
            "includeDiagnostics"
          ],
          "type": "object"
        },
        "type": "array"
      }
    }
  },
  "list_dir": {
    "description": "一覧を取得します the contents of a ディレクトリ. The quick ツール to use for discovery, before using more targeted ツール like codebase 検索します or ファイル reading. Useful to try to understand the ファイル structure before diving deeper into specific ファイル. Can be used to explore the codebase.",
    "parameters": {
      "path": {
        "description": "The パス of the ディレクトリ to 一覧を取得します contents for. Use absolute パス.",
        "sanitizePath": true,
        "type": "string"
      },
      "recursive": {
        "description": "Whether to 一覧を取得します ファイル recursively. Use 'true' for recursive listing, 'false' or omit for top-level only.",
        "type": "boolean"
      }
    }
  },
  "file_search": {
    "description": "Fast ファイル 検索します based on fuzzy matching against ファイル パス. Use if you know part of the ファイル パス but don't know where it's located exactly. Response will be capped to 10 結果. Make your クエリ more specific if need to フィルタします 結果 further. It is always better to speculatively perform multiple 検索します as a batch that are potentially useful.",
    "parameters": {
      "pattern": {
        "description": "Fuzzy filename to 検索します for",
        "type": "string"
      }
    }
  },
  "grep_search": {
    "description": "Fast text-based regex 検索します that finds exact pattern matches within ファイル or directories, utilizing the ripgrep コマンド for efficient searching. 結果 will be formatted in the style of ripgrep and can be configured to include line numbers and content. To avoid overwhelming 出力, the 結果 are capped at 50 matches. Use the include patterns to フィルタします the 検索します scope by ファイル type or specific パス. This is best for finding exact text matches or regex patterns. More precise than codebase 検索します for finding specific strings or patterns. This is preferred over codebase 検索します when we know the exact symbol/function name/etc. to 検索します in some set of directories/ファイル types.",
    "parameters": {
      "includePattern": {
        "anyOf": [
          {
            "description": "Glob pattern for ファイル to include (e.g., '*.ts' for TypeScript ファイル). If not provided, it will 検索します all ファイル (*).",
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "regex": {
        "description": "The regex pattern to 検索します for.",
        "type": "string"
      }
    }
  },
  "web_search": {
    "description": "Performs web 検索します to find relevant information and documentation for the given クエリ. This ツール helps gather external knowledge useful for solving tasks, especially for obtaining the latest information or documentation.",
    "parameters": {
      "query": {
        "description": "The 検索します クエリ to look up on the web.",
        "type": "string"
      }
    }
  },
  "get_diagnostics": {
    "description": "Retrieve diagnostics for multiple ファイル matching a glob pattern, including エラー, 警告, and lint suggestions, by analyzing its code using the built-in LSP. Use this functionality to identify and resolve specific Issue across multiple ファイル that match a specific pattern.",
    "parameters": {
      "directories": {
        "description": "Directories from which to retrieve diagnostics. Use absolute パス. Provide 開きます workspace directories if you want to 検索します all ファイル in the workspace.",
        "items": {
          "description": "ディレクトリ to 検索します for ファイル. Use absolute パス.",
          "type": "string"
        },
        "type": "array"
      },
      "includePattern": {
        "anyOf": [
          {
            "description": "Glob pattern for ファイル to include (e.g., '*.ts' for TypeScript ファイル). If not provided, it will 検索します all ファイル (*).",
            "type": "string"
          },
          {
            "description": "If not provided, 返します all severity levels.",
            "type": "null"
          }
        ]
      },
      "severity": {
        "anyOf": [
          {
            "description": "Severity level of diagnostics to retrieve.",
            "enum": [
              "Error",
              "Warning",
              "Information",
              "Hint"
            ],
            "type": "string"
          },
          {
            "description": "If not provided, 返します all severity levels.",
            "type": "null"
          }
        ]
      }
    }
  },
  "file_outlines": {
    "description": "Get a symbol outline for all ファイル at the top level of a specified ディレクトリ. This can be particularly useful when you need to understand the code present in multiple ファイル at a high-level.",
    "parameters": {
      "path": {
        "description": "The パス of the ディレクトリ to get ファイル outlines for. Use absolute パス.",
        "sanitizePath": true,
        "type": "string"
      }
    }
  },
  "find_references": {
    "description": "Find references (usage, mentions etc.) of a function, method, class, interface etc. Use this ツール to jump to the all the locations where the given symbol is being used in the codebase. Software developers use this capability extensively to explore large codebases with precision. Prefer this over codebase_search when you need to lookup references of a symbol (anything tracked by LSP). You need to provide the ファイル and line number wherever the symbol is MENTIONED. Find references ツール will automatically take you to the relavant location. This works for locations both internal or external to the project.",
    "parameters": {
      "line": {
        "anyOf": [
          {
            "description": "The line number where the symbol is mentioned. This field is optional. If omitted, it will match the first occurence of this symbol in the ファイル.",
            "type": "number"
          },
          {
            "type": "null"
          }
        ]
      },
      "path": {
        "anyOf": [
          {
            "description": "The パス of the ファイル where the symbol is mentioned. If omitted, it will match the last ファイル with this symbol in the chat. Use absolute パス.",
            "sanitizePath": true,
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "symbol": {
        "description": "The name of the symbol for which you want to find references.",
        "type": "string"
      }
    }
  },
  "go_to_definition": {
    "description": "Go to Definition of a function, method, class, interface etc. Use this ツール to jump to the defintion of a symbol. Software developers use this capability extensively to explore large codebases with precision. Prefer this over codebase_search when you need to lookup definitions of a symbol (anything tracked by LSP). You may provide the ファイル and line number wherever the symbol is MENTIONED. This ツール can also work just on the symbol alone although providing ファイル and symbols will give more precise 結果. Go to Definition ツール will automatically take you to the relavant location. This works for locations both internal or external to the project.",
    "parameters": {
      "line": {
        "anyOf": [
          {
            "description": "The line number where the symbol is mentioned. This field is optional. If omitted, it will match the first occurence of this symbol in the ファイル.",
            "type": "number"
          },
          {
            "type": "null"
          }
        ]
      },
      "path": {
        "anyOf": [
          {
            "description": "The パス of the ファイル where the symbol is mentioned. If omitted, it will match the last ファイル with this symbol in the chat. Use absolute パス.",
            "sanitizePath": true,
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "symbol": {
        "description": "The name of the symbol for which you want to find the definition.",
        "type": "string"
      }
    }
  },
  "go_to_implementations": {
    "description": "Use the built-in LSP to \"Go to Implementations\" of a given abstract class or function symbol.",
    "parameters": {
      "line": {
        "anyOf": [
          {
            "description": "The line number where the symbol is mentioned. This field is optional. If omitted, it will match the first occurence of this symbol in the ファイル.",
            "type": "number"
          },
          {
            "type": "null"
          }
        ]
      },
      "path": {
        "anyOf": [
          {
            "description": "The パス of the ファイル where the symbol is mentioned. If omitted, it will match the last ファイル with this symbol in the chat. Use absolute パス.",
            "sanitizePath": true,
            "type": "string"
          },
          {
            "type": "null"
          }
        ]
      },
      "symbol": {
        "description": "The name of the symbol for which you want to find the implementations.",
        "type": "string"
      }
    }
  },
  "explanation_response": {
    "description": "- You are diligent and thorough! You NEVER leave any parts ambiguous in the explanation.\n- Provide clear, concise explanations that are easy to understand.\n- Use markdown format for better readability.",
    "parameters": {
      "canProposePhases": {
        "description": "Set to true only when the explanation includes an implementation strategy that could be broken into actionable phases.\n\nFor 例:\n**Set to TRUE when:**\n* You provide a complete solution architecture with implementation steps (e.g., JSON serialization redesign).\n* You explain \"how to implement feature X\" with specific technical steps.\n* You propose a refactor with clear guidance.\n* You outline architectural changes with implementation details.\n* When you present an analysis to a problem along with a solution.\n\n**Leave FALSE when,\n• It's purely conceptual (\"What is dependency injection?\").\n• You're only diagnosing a problem without giving a fix (\"Here's why your code is slow\").\n• It's a comparative analysis (React vs Vue pros/cons).\n• You're just explaining why an エラー occurs without prescribing changes.",
        "type": "boolean"
      },
      "explanation": {
        "description": "Provide a clear and comprehensive explanation of the topic or concept. Optimize for readability and use markdown formatting.",
        "type": "string"
      },
      "mermaid": {
        "description": "生成します a Mermaid diagram to visualize the concept or flow. The diagram should be simple and easy to understand, focusing on the key aspects.\n\nYou are allowed one of the following mermaid diagram types:\n- sequenceDiagram (preferred approach)\n- graph TD\n- flowchart TD\n- classDiagram\n- stateDiagram\n\nWhere to use which diagram type:\n1. Most scenarios are best representable as a sequenceDiagram. You should always prefer it over other diagram types.\n2. Certain scenarios can be represented as graph TD, 例:, showing relationships between components.\n3. Use flowchart TD to represent complex flows (conditionals, loops, etc).\n4. Use classDiagram to represent class hierarchies.\n5. Use stateDiagram to represent state machines.\n\nDO NOT 生成します any mermaid diagram when it does not make sense, 例:, when the concept is too simple or when a diagram wouldn't add value.",
        "type": "string"
      }
    }
  },
  "ask_user_for_clarification": {
    "description": "Use this ツール to ask the user for clarification or 入力 on key design decisions.",
    "parameters": {
      "questions": {
        "description": "Keep your questions brief and to the point. Provide options if applicable. Use markdown formatting.",
        "type": "string"
      }
    }
  },
  "write_phases": {
    "description": "Use this ツール to break any sizeable coding task—refactor or new feature—into *independently executable phases* that **always leave the codebase compiling and all tests green**. Stay laser-focused on code-level work; skip phases that belong to infra provision, deployment, monitoring, or other non-development concerns.\n\n### Phase-sizing guidelines\n\n* Treat each phase like a well-scoped プルリクエスト: one coherent chunk of work that reviewers can grasp at a glance.\n* If a single ファイル refactor (or similarly small change) completes the task, keep it to one phase—don't force extra steps.\n* Conversely, split phases when a change grows too large or mixes unrelated concerns.\n\n### Core principles\n\n1. **Shadow, don't overwrite**\n  * Introduce parallel symbols (e.g., `Thing2`) instead of modifying the legacy implementation.\n  * Keep the original パス alive and functional until the final \"cut-over\" phase.\n\n2. **Phase-by-phase integrity**\n  * Every phase must compile, run existing tests, and, where necessary, add new ones.\n  * Do not advance while dead code, broken interfaces, or failing 確認します remain.\n  * For 例, if an API's 返します type changes, 更新します all its consumers in the same phase.\n\n3. **Leverage the legacy reference**\n  * Continuously 比較します new code to the old implementation.\n  * Can add explicit phases or instructions in phases to do this at critical junctures.\n\n4. **Final phase**\n  * This phase needs to verify that the required behavior is fully reproduced.\n  * Rename or swap entry points, remove `Thing` vs `Thing2` duplication, and 削除します obsolete パス once the new code is proven.\n\nNote: Before coming up with phase breakdown, step back to make sure you are following the core principles and guidelines.",
    "parameters": {
      "howDidIGetHere": {
        "description": "Keep this section under 150 words, and use markdown format. Document the investigative steps and discoveries that shaped the phase plan. Do not mention exact ツール names, instead mention that as a verb. E.g. list_files ツール call can be described as 'I listed the ファイル'.",
        "type": "string"
      },
      "phases": {
        "description": "A phase by phase approach to implement the given task.",
        "items": {
          "properties": {
            "id": {
              "description": "A unique identifier for the phase.",
              "type": "string"
            },
            "promptForAgent": {
              "description": "A crisp and to the point プロンプト that AI agents can use to implement this phase. Do mention any relevant components, modules or フォルダ in the codebase and make sure to enclose them backticks. Use markdown formatting. The プロンプト should be in 3-4 points and under 60 words.",
              "type": "string"
            },
            "referredFiles": {
              "items": {
                "description": "Absolute ファイル パス that should be referred by the agent to implement this phase.",
                "type": "string"
              },
              "type": "array"
            },
            "title": {
              "description": "A title for the phase.",
              "type": "string"
            }
          },
          "required": [
            "id",
            "title",
            "promptForAgent",
            "referredFiles"
          ],
          "type": "object"
        },
        "type": "array"
      },
      "reasoning": {
        "description": "Explain why you are breaking the phases this way. Are you following the guidelines and core principles for phase breakdown?",
        "type": "string"
      }
    }
  }
}
