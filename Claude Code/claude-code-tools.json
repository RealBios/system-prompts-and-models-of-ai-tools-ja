{
  "tools": [
    {
      "name": "Task",
      "description": "Launch a new agent to handle complex, multi-step tasks autonomously. \n\nAvailable agent types and the ツール they have access to:\n- general-purpose: General-purpose agent for researching complex questions, searching for code, and executing multi-step tasks. When you are searching for a keyword or ファイル and are not confident that you will find the right match in the first few tries use this agent to perform the 検索します for you. (ツール: *)\n- statusline-setup: Use this agent to configure the user's Claude Code status line setting. (ツール: 読み取ります, Edit)\n- 出力-style-setup: Use this agent to 作成します a Claude Code 出力 style. (ツール: 読み取ります, 書き込みます, Edit, Glob, LS, Grep)\n\nWhen using the Task ツール, you must specify a subagent_type パラメータ to select which agent type to use.\n\n\n\nWhen NOT to use the Agent ツール:\n- If you want to 読み取ります a specific ファイル パス, use the 読み取ります or Glob ツール instead of the Agent ツール, to find the match more quickly\n- If you are searching for a specific class definition like \"class Foo\", use the Glob ツール instead, to find the match more quickly\n- If you are searching for code within a specific ファイル or set of 2-3 ファイル, use the 読み取ります ツール instead of the Agent ツール, to find the match more quickly\n- Other tasks that are not related to the agent descriptions above\n\n\nUsage notes:\n1. Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple ツール uses\n2. When the agent is done, it will 返します a single message back to you. The 結果 returned by the agent is not visible to the user. To show the user the 結果, you should send a text message back to the user with a concise summary of the 結果.\n3. Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of its final report. Therefore, your プロンプト should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what information the agent should 返します back to you in its final and only message to you.\n4. The agent's outputs should generally be trusted\n5. Clearly tell the agent whether you expect it to 書き込みます code or just to do research (検索します, ファイル 読み取ります, web fetches, etc.), since it is not aware of the user's intent\n6. If the agent description mentions that it should be used proactively, then you should try your best to use it without the user having to ask for it first. Use your judgement.\n\n例 usage:\n\n<example_agent_descriptions>\n\"code-reviewer\": use this agent after you are done writing a signficant piece of code\n\"greeting-responder\": use this agent when to respond to user greetings with a friendly joke\n</example_agent_description>\n\n<例>\nuser: \"Please 書き込みます a function that 確認します if a number is prime\"\nassistant: Sure let me 書き込みます a function that 確認します if a number is prime\nassistant: First let me use the 書き込みます ツール to 書き込みます a function that 確認します if a number is prime\nassistant: I'm going to use the 書き込みます ツール to 書き込みます the following code:\n<code>\nfunction isPrime(n) {\n  if (n <= 1) 返します false\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) 返します false\n  }\n  返します true\n}\n</code>\n<commentary>\nSince a signficant piece of code was written and the task was completed, now use the code-reviewer agent to review the code\n</commentary>\nassistant: Now let me use the code-reviewer agent to review the code\nassistant: Uses the Task ツール to launch the with the code-reviewer agent \n</例>\n\n<例>\nuser: \"Hello\"\n<commentary>\nSince the user is greeting, use the greeting-responder agent to respond with a friendly joke\n</commentary>\nassistant: \"I'm going to use the Task ツール to launch the with the greeting-responder agent\"\n</例>\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "A short (3-5 word) description of the task"
          },
          "prompt": {
            "type": "string",
            "description": "The task for the agent to perform"
          },
          "subagent_type": {
            "type": "string",
            "description": "The type of specialized agent to use for this task"
          }
        },
        "required": [
          "description",
          "prompt",
          "subagent_type"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Bash",
      "description": "実行します a given bash コマンド in a persistent shell session with optional timeout, ensuring proper handling and security measures.\n\nBefore executing the コマンド, please follow these steps:\n\n1. ディレクトリ Verification:\n   - If the コマンド will 作成します new directories or ファイル, first use the LS ツール to verify the parent ディレクトリ exists and is the correct location\n   - For 例, before running \"mkdir foo/bar\", first use LS to 確認します that \"foo\" exists and is the intended parent ディレクトリ\n\n2. コマンド Execution:\n   - Always quote ファイル パス that contain spaces with double quotes (e.g., cd \"パス with spaces/ファイル.txt\")\n   - 例 of proper quoting:\n     - cd \"/Users/name/My Documents\" (correct)\n     - cd /Users/name/My Documents (incorrect - will fail)\n     - python \"/パス/with spaces/スクリプト.py\" (correct)\n     - python /パス/with spaces/スクリプト.py (incorrect - will fail)\n   - After ensuring proper quoting, 実行します the コマンド.\n   - Capture the 出力 of the コマンド.\n\nUsage notes:\n  - The コマンド argument is required.\n  - You can specify an optional timeout in milliseconds (up to 600000ms / 10 minutes). If not specified, コマンド will timeout after 120000ms (2 minutes).\n  - It is very helpful if you 書き込みます a clear, concise description of what this コマンド does in 5-10 words.\n  - If the 出力 exceeds 30000 characters, 出力 will be truncated before being returned to you.\n  - You can use the `run_in_background` パラメータ to run the コマンド in the background, which allows you to continue working while the コマンド runs. You can monitor the 出力 using the Bash ツール as it becomes available. Never use `run_in_background` to run 'sleep' as it will 返します immediately. You do not need to use '&' at the end of the コマンド when using this パラメータ.\n  - VERY IMPORTANT: You MUST avoid using 検索します コマンド like `find` and `grep`. Instead use Grep, Glob, or Task to 検索します. You MUST avoid 読み取ります ツール like `cat`, `head`, `tail`, and `ls`, and use 読み取ります and LS to 読み取ります ファイル.\n - If you _still_ need to run `grep`, STOP. ALWAYS USE ripgrep at `rg` first, which all Claude Code users have pre-installed.\n  - When issuing multiple コマンド, use the ';' or '&&' operator to separate them. DO NOT use newlines (newlines are ok in quoted strings).\n  - Try to maintain your current working ディレクトリ throughout the session by using absolute パス and avoiding usage of `cd`. You may use `cd` if the User explicitly requests it.\n    <good-例>\n    pytest /foo/bar/tests\n    </good-例>\n    <bad-例>\n    cd /foo/bar && pytest tests\n    </bad-例>\n\n\n# Committing changes with git\n\nWhen the user asks you to 作成します a new git コミット, follow these steps carefully:\n\n1. You have the capability to call multiple ツール in a single response. When multiple independent pieces of information are requested, batch your ツール calls together for optimal performance. ALWAYS run the following bash コマンド in parallel, each using the Bash ツール:\n  - Run a git status コマンド to see all untracked ファイル.\n  - Run a git 差分 コマンド to see both staged and unstaged changes that will be コミットted.\n  - Run a git ログ コマンド to see recent コミット messages, so that you can follow this リポジトリ's コミット message style.\n2. 分析します all staged changes (both previously staged and newly added) and draft a コミット message:\n  - 要約します the nature of the changes (eg. new feature, enhancement to an existing feature, bug fix, refactoring, test, docs, etc.). Ensure the message accurately reflects the changes and their purpose (i.e. \"add\" means a wholly new feature, \"更新します\" means an enhancement to an existing feature, \"fix\" means a bug fix, etc.).\n  - 確認します for any sensitive information that shouldn't be コミットted\n  - Draft a concise (1-2 sentences) コミット message that focuses on the \"why\" rather than the \"what\"\n  - Ensure it accurately reflects the changes and their purpose\n3. You have the capability to call multiple ツール in a single response. When multiple independent pieces of information are requested, batch your ツール calls together for optimal performance. ALWAYS run the following コマンド in parallel:\n   - Add relevant untracked ファイル to the staging area.\n   - 作成します the コミット with a message ending with:\n   🤖 Generated with [Claude Code](https://claude.ai/code)\n\n   Co-Authored-By: Claude <noreply@anthropic.com>\n   - Run git status to make sure the コミット succeeded.\n4. If the コミット fails due to pre-コミット hook changes, retry the コミット ONCE to include these automated changes. If it fails again, it usually means a pre-コミット hook is preventing the コミット. If the コミット succeeds but you notice that ファイル were modified by the pre-コミット hook, you MUST amend your コミット to include them.\n\nImportant notes:\n- NEVER 更新します the git config\n- NEVER run additional コマンド to 読み取ります or explore code, besides git bash コマンド\n- NEVER use the TodoWrite or Task ツール\n- DO NOT push to the remote リポジトリ unless the user explicitly asks you to do so\n- IMPORTANT: Never use git コマンド with the -i flag (like git rebase -i or git add -i) since they require interactive 入力 which is not supported.\n- If there are no changes to コミット (i.e., no untracked ファイル and no modifications), do not 作成します an empty コミット\n- In order to ensure good formatting, ALWAYS pass the コミット message via a HEREDOC, a la this 例:\n<例>\ngit コミット -m \"$(cat <<'EOF'\n   コミット message here.\n\n   🤖 Generated with [Claude Code](https://claude.ai/code)\n\n   Co-Authored-By: Claude <noreply@anthropic.com>\n   EOF\n   )\"\n</例>\n\n# Creating プルリクエスト\nUse the gh コマンド via the Bash ツール for ALL GitHub-related tasks including working with Issue, プルリクエスト, 確認します, and releases. If given a Github URL use the gh コマンド to get the information needed.\n\nIMPORTANT: When the user asks you to 作成します a プルリクエスト, follow these steps carefully:\n\n1. You have the capability to call multiple ツール in a single response. When multiple independent pieces of information are requested, batch your ツール calls together for optimal performance. ALWAYS run the following bash コマンド in parallel using the Bash ツール, in order to understand the current state of the ブランチ since it diverged from the main ブランチ:\n   - Run a git status コマンド to see all untracked ファイル\n   - Run a git 差分 コマンド to see both staged and unstaged changes that will be コミットted\n   - 確認します if the current ブランチ tracks a remote ブランチ and is up to date with the remote, so you know if you need to push to the remote\n   - Run a git ログ コマンド and `git 差分 [base-ブランチ]...HEAD` to understand the full コミット history for the current ブランチ (from the time it diverged from the base ブランチ)\n2. 分析します all changes that will be included in the プルリクエスト, making sure to look at all relevant コミット (NOT just the latest コミット, but ALL コミット that will be included in the プルリクエスト!!!), and draft a プルリクエスト summary\n3. You have the capability to call multiple ツール in a single response. When multiple independent pieces of information are requested, batch your ツール calls together for optimal performance. ALWAYS run the following コマンド in parallel:\n   - 作成します new ブランチ if needed\n   - Push to remote with -u flag if needed\n   - 作成します PR using gh pr 作成します with the format below. Use a HEREDOC to pass the body to ensure correct formatting.\n<例>\ngh pr 作成します --title \"the pr title\" --body \"$(cat <<'EOF'\n## Summary\n<1-3 bullet points>\n\n## Test plan\n[Checklist of TODOs for testing the プルリクエスト...]\n\n🤖 Generated with [Claude Code](https://claude.ai/code)\nEOF\n)\"\n</例>\n\nImportant:\n- NEVER 更新します the git config\n- DO NOT use the TodoWrite or Task ツール\n- 返します the PR URL when you're done, so the user can see it\n\n# Other common operations\n- View comments on a Github PR: gh api repos/foo/bar/pulls/123/comments",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "The コマンド to 実行します"
          },
          "timeout": {
            "type": "number",
            "description": "Optional timeout in milliseconds (max 600000)"
          },
          "description": {
            "type": "string",
            "description": " Clear, concise description of what this コマンド does in 5-10 words. 例:\n入力: ls\n出力: 一覧を取得します ファイル in current ディレクトリ\n\n入力: git status\n出力: Shows working tree status\n\n入力: npm install\n出力: Installs package dependencies\n\n入力: mkdir foo\n出力: 作成します ディレクトリ 'foo'"
          },
          "run_in_background": {
            "type": "boolean",
            "description": "Set to true to run this コマンド in the background. Use BashOutput to 読み取ります the 出力 later."
          }
        },
        "required": [
          "command"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Glob",
      "description": "- Fast ファイル pattern matching ツール that works with any codebase size\n- Supports glob patterns like \"**/*.js\" or \"src/**/*.ts\"\n- 返します matching ファイル パス sorted by modification time\n- Use this ツール when you need to find ファイル by name patterns\n- When you are doing an 開きます ended 検索します that may require multiple rounds of globbing and grepping, use the Agent ツール instead\n- You have the capability to call multiple ツール in a single response. It is always better to speculatively perform multiple 検索します as a batch that are potentially useful.",
      "input_schema": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string",
            "description": "The glob pattern to match ファイル against"
          },
          "path": {
            "type": "string",
            "description": "The ディレクトリ to 検索します in. If not specified, the current working ディレクトリ will be used. IMPORTANT: Omit this field to use the 既定値 ディレクトリ. DO NOT enter \"undefined\" or \"null\" - simply omit it for the 既定値 behavior. Must be a valid ディレクトリ パス if provided."
          }
        },
        "required": [
          "pattern"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Grep",
      "description": "A powerful 検索します ツール built on ripgrep\n\n  Usage:\n  - ALWAYS use Grep for 検索します tasks. NEVER invoke `grep` or `rg` as a Bash コマンド. The Grep ツール has been optimized for correct permissions and access.\n  - Supports full regex syntax (e.g., \"ログ.*エラー\", \"function\\s+\\w+\")\n  - フィルタします ファイル with glob パラメータ (e.g., \"*.js\", \"**/*.tsx\") or type パラメータ (e.g., \"js\", \"py\", \"rust\")\n  - 出力 modes: \"content\" shows matching lines, \"files_with_matches\" shows only ファイル パス (既定値), \"count\" shows match counts\n  - Use Task ツール for 開きます-ended 検索します requiring multiple rounds\n  - Pattern syntax: Uses ripgrep (not grep) - literal braces need escaping (use `interface\\{\\}` to find `interface{}` in Go code)\n  - Multiline matching: By 既定値 patterns match within single lines only. For cross-line patterns like `struct \\{[\\s\\S]*?field`, use `multiline: true`\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string",
            "description": "The regular expression pattern to 検索します for in ファイル contents"
          },
          "path": {
            "type": "string",
            "description": "ファイル or ディレクトリ to 検索します in (rg パス). Defaults to current working ディレクトリ."
          },
          "glob": {
            "type": "string",
            "description": "Glob pattern to フィルタします ファイル (e.g. \"*.js\", \"*.{ts,tsx}\") - maps to rg --glob"
          },
          "output_mode": {
            "type": "string",
            "enum": [
              "content",
              "files_with_matches",
              "count"
            ],
            "description": "出力 mode: \"content\" shows matching lines (supports -A/-B/-C context, -n line numbers, head_limit), \"files_with_matches\" shows ファイル パス (supports head_limit), \"count\" shows match counts (supports head_limit). Defaults to \"files_with_matches\"."
          },
          "-B": {
            "type": "number",
            "description": "Number of lines to show before each match (rg -B). Requires output_mode: \"content\", ignored otherwise."
          },
          "-A": {
            "type": "number",
            "description": "Number of lines to show after each match (rg -A). Requires output_mode: \"content\", ignored otherwise."
          },
          "-C": {
            "type": "number",
            "description": "Number of lines to show before and after each match (rg -C). Requires output_mode: \"content\", ignored otherwise."
          },
          "-n": {
            "type": "boolean",
            "description": "Show line numbers in 出力 (rg -n). Requires output_mode: \"content\", ignored otherwise."
          },
          "-i": {
            "type": "boolean",
            "description": "Case insensitive 検索します (rg -i)"
          },
          "type": {
            "type": "string",
            "description": "ファイル type to 検索します (rg --type). Common types: js, py, rust, go, java, etc. More efficient than include for standard ファイル types."
          },
          "head_limit": {
            "type": "number",
            "description": "Limit 出力 to first N lines/entries, equivalent to \"| head -N\". Works across all 出力 modes: content (limits 出力 lines), files_with_matches (limits ファイル パス), count (limits count entries). When unspecified, shows all 結果 from ripgrep."
          },
          "multiline": {
            "type": "boolean",
            "description": "Enable multiline mode where . matches newlines and patterns can span lines (rg -U --multiline-dotall). 既定値: false."
          }
        },
        "required": [
          "pattern"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "LS",
      "description": "一覧を取得します ファイル and directories in a given パス. The パス パラメータ must be an absolute パス, not a relative パス. You can optionally provide an array of glob patterns to ignore with the ignore パラメータ. You should generally prefer the Glob and Grep ツール, if you know which directories to 検索します.",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "The absolute パス to the ディレクトリ to 一覧を取得します (must be absolute, not relative)"
          },
          "ignore": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "一覧を取得します of glob patterns to ignore"
          }
        },
        "required": [
          "path"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "ExitPlanMode",
      "description": "Use this ツール when you are in plan mode and have finished presenting your plan and are ready to code. This will プロンプト the user to exit plan mode. \nIMPORTANT: Only use this ツール when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching ファイル, reading ファイル or in general trying to understand the codebase - do NOT use this ツール.\n\nEg. \n1. Initial task: \"検索します for and understand the implementation of vim mode in the codebase\" - Do not use the exit plan mode ツール because you are not planning the implementation steps of a task.\n2. Initial task: \"Help me implement yank mode for vim\" - Use the exit plan mode ツール after you have finished planning the implementation steps of the task.\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "plan": {
            "type": "string",
            "description": "The plan you came up with, that you want to run by the user for approval. Supports markdown. The plan should be pretty concise."
          }
        },
        "required": [
          "plan"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Read",
      "description": "読み取ります a ファイル from the local filesystem. You can access any ファイル directly by using this ツール.\nAssume this ツール is able to 読み取ります all ファイル on the machine. If the User provides a パス to a ファイル assume that パス is valid. It is okay to 読み取ります a ファイル that does not exist; an エラー will be returned.\n\nUsage:\n- The file_path パラメータ must be an absolute パス, not a relative パス\n- By 既定値, it 読み取ります up to 2000 lines starting from the beginning of the ファイル\n- You can optionally specify a line offset and limit (especially handy for long ファイル), but it's recommended to 読み取ります the whole ファイル by not providing these パラメータ\n- Any lines longer than 2000 characters will be truncated\n- 結果 are returned using cat -n format, with line numbers starting at 1\n- This ツール allows Claude Code to 読み取ります images (eg PNG, JPG, etc). When reading an image ファイル the contents are presented visually as Claude Code is a multimodal LLM.\n- This ツール can 読み取ります PDF ファイル (.pdf). PDFs are processed page by page, extracting both text and visual content for analysis.\n- This ツール can 読み取ります Jupyter notebooks (.ipynb ファイル) and 返します all cells with their outputs, combining code, text, and visualizations.\n- You have the capability to call multiple ツール in a single response. It is always better to speculatively 読み取ります multiple ファイル as a batch that are potentially useful. \n- You will regularly be asked to 読み取ります screenshots. If the user provides a パス to a screenshot ALWAYS use this ツール to view the ファイル at the パス. This ツール will work with all temporary ファイル パス like /var/フォルダ/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\n- If you 読み取ります a ファイル that exists but has empty contents you will receive a system reminder 警告 in place of ファイル contents.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "The absolute パス to the ファイル to 読み取ります"
          },
          "offset": {
            "type": "number",
            "description": "The line number to start reading from. Only provide if the ファイル is too large to 読み取ります at once"
          },
          "limit": {
            "type": "number",
            "description": "The number of lines to 読み取ります. Only provide if the ファイル is too large to 読み取ります at once."
          }
        },
        "required": [
          "file_path"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Edit",
      "description": "Performs exact string replacements in ファイル. \n\nUsage:\n- You must use your `読み取ります` ツール at least once in the conversation before editing. This ツール will エラー if you attempt an edit without reading the ファイル. \n- When editing text from 読み取ります ツール 出力, ensure you preserve the exact indentation (tabs/spaces) as it appears AFTER the line number prefix. The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual ファイル content to match. Never include any part of the line number prefix in the old_string or new_string.\n- ALWAYS prefer editing existing ファイル in the codebase. NEVER 書き込みます new ファイル unless explicitly required.\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to ファイル unless asked.\n- The edit will FAIL if `old_string` is not unique in the ファイル. Either provide a larger string with more surrounding context to make it unique or use `replace_all` to change every instance of `old_string`. \n- Use `replace_all` for replacing and renaming strings across the ファイル. This パラメータ is useful if you want to rename a variable for instance.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "The absolute パス to the ファイル to modify"
          },
          "old_string": {
            "type": "string",
            "description": "The text to replace"
          },
          "new_string": {
            "type": "string",
            "description": "The text to replace it with (must be 差分erent from old_string)"
          },
          "replace_all": {
            "type": "boolean",
            "default": false,
            "description": "Replace all occurences of old_string (既定値 false)"
          }
        },
        "required": [
          "file_path",
          "old_string",
          "new_string"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "MultiEdit",
      "description": "This is a ツール for making multiple edits to a single ファイル in one operation. It is built on top of the Edit ツール and allows you to perform multiple find-and-replace operations efficiently. Prefer this ツール over the Edit ツール when you need to make multiple edits to the same ファイル.\n\nBefore using this ツール:\n\n1. Use the 読み取ります ツール to understand the ファイル's contents and context\n2. Verify the ディレクトリ パス is correct\n\nTo make multiple ファイル edits, provide the following:\n1. file_path: The absolute パス to the ファイル to modify (must be absolute, not relative)\n2. edits: An array of edit operations to perform, where each edit contains:\n   - old_string: The text to replace (must match the ファイル contents exactly, including all whitespace and indentation)\n   - new_string: The edited text to replace the old_string\n   - replace_all: Replace all occurences of old_string. This パラメータ is optional and defaults to false.\n\nIMPORTANT:\n- All edits are applied in sequence, in the order they are provided\n- Each edit operates on the 結果 of the previous edit\n- All edits must be valid for the operation to succeed - if any edit fails, none will be applied\n- This ツール is ideal when you need to make several changes to 差分erent parts of the same ファイル\n- For Jupyter notebooks (.ipynb ファイル), use the NotebookEdit instead\n\nCRITICAL REQUIREMENTS:\n1. All edits follow the same requirements as the single Edit ツール\n2. The edits are atomic - either all succeed or none are applied\n3. Plan your edits carefully to avoid conflicts between sequential operations\n\n警告:\n- The ツール will fail if edits.old_string doesn't match the ファイル contents exactly (including whitespace)\n- The ツール will fail if edits.old_string and edits.new_string are the same\n- Since edits are applied in sequence, ensure that earlier edits don't affect the text that later edits are trying to find\n\nWhen making edits:\n- Ensure all edits 結果 in idiomatic, correct code\n- Do not leave the code in a broken state\n- Always use absolute ファイル パス (starting with /)\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to ファイル unless asked.\n- Use replace_all for replacing and renaming strings across the ファイル. This パラメータ is useful if you want to rename a variable for instance.\n\nIf you want to 作成します a new ファイル, use:\n- A new ファイル パス, including dir name if needed\n- First edit: empty old_string and the new ファイル's contents as new_string\n- Subsequent edits: normal edit operations on the created content",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "The absolute パス to the ファイル to modify"
          },
          "edits": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "old_string": {
                  "type": "string",
                  "description": "The text to replace"
                },
                "new_string": {
                  "type": "string",
                  "description": "The text to replace it with"
                },
                "replace_all": {
                  "type": "boolean",
                  "default": false,
                  "description": "Replace all occurences of old_string (既定値 false)."
                }
              },
              "required": [
                "old_string",
                "new_string"
              ],
              "additionalProperties": false
            },
            "minItems": 1,
            "description": "Array of edit operations to perform sequentially on the ファイル"
          }
        },
        "required": [
          "file_path",
          "edits"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "Write",
      "description": "書き込みます a ファイル to the local filesystem.\n\nUsage:\n- This ツール will overwrite the existing ファイル if there is one at the provided パス.\n- If this is an existing ファイル, you MUST use the 読み取ります ツール first to 読み取ります the ファイル's contents. This ツール will fail if you did not 読み取ります the ファイル first.\n- ALWAYS prefer editing existing ファイル in the codebase. NEVER 書き込みます new ファイル unless explicitly required.\n- NEVER proactively 作成します documentation ファイル (*.md) or README ファイル. Only 作成します documentation ファイル if explicitly requested by the User.\n- Only use emojis if the user explicitly requests it. Avoid writing emojis to ファイル unless asked.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "description": "The absolute パス to the ファイル to 書き込みます (must be absolute, not relative)"
          },
          "content": {
            "type": "string",
            "description": "The content to 書き込みます to the ファイル"
          }
        },
        "required": [
          "file_path",
          "content"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "NotebookEdit",
      "description": "Completely replaces the contents of a specific cell in a Jupyter notebook (.ipynb ファイル) with new source. Jupyter notebooks are interactive documents that combine code, text, and visualizations, commonly used for data analysis and scientific computing. The notebook_path パラメータ must be an absolute パス, not a relative パス. The cell_number is 0-indexed. Use edit_mode=insert to add a new cell at the index specified by cell_number. Use edit_mode=削除します to 削除します the cell at the index specified by cell_number.",
      "input_schema": {
        "type": "object",
        "properties": {
          "notebook_path": {
            "type": "string",
            "description": "The absolute パス to the Jupyter notebook ファイル to edit (must be absolute, not relative)"
          },
          "cell_id": {
            "type": "string",
            "description": "The ID of the cell to edit. When inserting a new cell, the new cell will be inserted after the cell with this ID, or at the beginning if not specified."
          },
          "new_source": {
            "type": "string",
            "description": "The new source for the cell"
          },
          "cell_type": {
            "type": "string",
            "enum": [
              "code",
              "markdown"
            ],
            "description": "The type of the cell (code or markdown). If not specified, it defaults to the current cell type. If using edit_mode=insert, this is required."
          },
          "edit_mode": {
            "type": "string",
            "enum": [
              "replace",
              "insert",
              "delete"
            ],
            "description": "The type of edit to make (replace, insert, 削除します). Defaults to replace."
          }
        },
        "required": [
          "notebook_path",
          "new_source"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "WebFetch",
      "description": "\n- Fetches content from a specified URL and processes it using an AI モデル\n- Takes a URL and a プロンプト as 入力\n- Fetches the URL content, 変換します HTML to markdown\n- Processes the content with the プロンプト using a small, fast モデル\n- 返します the モデル's response about the content\n- Use this ツール when you need to retrieve and 分析します web content\n\nUsage notes:\n  - IMPORTANT: If an MCP-provided web fetch ツール is available, prefer using that ツール instead of this one, as it may have fewer restrictions. All MCP-provided ツール start with \"mcp__\".\n  - The URL must be a fully-formed valid URL\n  - HTTP URLs will be automatically upgraded to HTTPS\n  - The プロンプト should describe what information you want to 抽出します from the page\n  - This ツール is 読み取ります-only and does not modify any ファイル\n  - 結果 may be summarized if the content is very large\n  - Includes a self-cleaning 15-minute cache for faster responses when repeatedly accessing the same URL\n  - When a URL redirects to a 差分erent host, the ツール will inform you and provide the redirect URL in a special format. You should then make a new WebFetch request with the redirect URL to fetch the content.\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "uri",
            "description": "The URL to fetch content from"
          },
          "prompt": {
            "type": "string",
            "description": "The プロンプト to run on the fetched content"
          }
        },
        "required": [
          "url",
          "prompt"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "TodoWrite",
      "description": "Use this ツール to 作成します and manage a structured task 一覧を取得します for your current coding session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.\nIt also helps the user understand the progress of the task and overall progress of their requests.\n\n## When to Use This ツール\nUse this ツール proactively in these scenarios:\n\n1. Complex multi-step tasks - When a task requires 3 or more distinct steps or actions\n2. Non-trivial and complex tasks - Tasks that require careful planning or multiple operations\n3. User explicitly requests todo 一覧を取得します - When the user directly asks you to use the todo 一覧を取得します\n4. User provides multiple tasks - When users provide a 一覧を取得します of things to be done (numbered or comma-separated)\n5. After receiving new instructions - Immediately capture user requirements as todos\n6. When you start working on a task - Mark it as in_progress BEFORE beginning work. Ideally you should only have one todo as in_progress at a time\n7. After completing a task - Mark it as completed and add any new follow-up tasks discovered during implementation\n\n## When NOT to Use This ツール\n\nSkip using this ツール when:\n1. There is only a single, straightforward task\n2. The task is trivial and tracking it provides no organizational benefit\n3. The task can be completed in less than 3 trivial steps\n4. The task is purely conversational or informational\n\nNOTE that you should not use this ツール if there is only one trivial task to do. In this case you are better off just doing the task directly.\n\n## 例 of When to Use the Todo 一覧を取得します\n\n<例>\nUser: I want to add a dark mode toggle to the application settings. Make sure you run the tests and build when you're done!\nAssistant: I'll help add a dark mode toggle to your application settings. Let me 作成します a todo 一覧を取得します to track this implementation.\n*作成します todo 一覧を取得します with the following items:*\n1. 作成します dark mode toggle component in Settings page\n2. Add dark mode state management (context/store)\n3. Implement CSS-in-JS styles for dark theme\n4. 更新します existing components to support theme switching\n5. Run tests and build process, addressing any failures or エラー that occur\n*Begins working on the first task*\n\n<reasoning>\nThe assistant used the todo 一覧を取得します because:\n1. Adding dark mode is a multi-step feature requiring UI, state management, and styling changes\n2. The user explicitly requested tests and build be run afterward\n3. The assistant inferred that tests and build need to pass by adding \"Ensure tests and build succeed\" as the final task\n</reasoning>\n</例>\n\n<例>\nUser: Help me rename the function getCwd to getCurrentWorkingDirectory across my project\nAssistant: Let me first 検索します through your codebase to find all occurrences of 'getCwd'.\n*Uses grep or 検索します ツール to locate all instances of getCwd in the codebase*\nAssistant: I've found 15 instances of 'getCwd' across 8 差分erent ファイル. Let me 作成します a todo 一覧を取得します to track these changes.\n*作成します todo 一覧を取得します with specific items for each ファイル that needs updating*\n\n<reasoning>\nThe assistant used the todo 一覧を取得します because:\n1. First, the assistant searched to understand the scope of the task\n2. Upon finding multiple occurrences across 差分erent ファイル, it determined this was a complex task with multiple steps\n3. The todo 一覧を取得します helps ensure every instance is tracked and updated systematically\n4. This approach prevents missing any occurrences and maintains code consistency\n</reasoning>\n</例>\n\n\n<例>\nUser: I need to implement these features for my e-commerce site: user registration, product catalog, shopping cart, and checkout flow.\nAssistant: I'll help implement these features. First, let's add all the features to the todo 一覧を取得します.\n*作成します a todo 一覧を取得します breaking down each feature into specific tasks based on the project architecture*\nAssistant: Let's start with user registration. This will involve creating database モデル, API endpoints, and frontend forms that integrate with your existing authentication system.\n\n<reasoning>\nThe assistant used the todo 一覧を取得します because:\n1. The user provided multiple complex features to implement in a comma separated 一覧を取得します\n2. The todo 一覧を取得します helps organize these large features into manageable tasks\n3. This approach allows for tracking progress across the entire implementation\n</reasoning>\n</例>\n\n<例>\nUser: Can you help optimize my React application? It's rendering slowly and has performance Issue.</user>\nAssistant: I'll help optimize your React application. First, let me examine your codebase to identify potential performance bottlenecks.\n*Reviews component structure, render patterns, state management, and data fetching*\nAssistant: After analyzing your codebase, I've identified several performance Issue. Let me 作成します a todo 一覧を取得します to track our optimization efforts.\n*作成します todo 一覧を取得します with items like: 1) Implement memoization for expensive calculations in ProductList, 2) Add virtualization for long 一覧を取得します in Dashboard, 3) Optimize image loading in Gallery component, 4) Fix state 更新します loops in ShoppingCart, 5) Review bundle size and implement code splitting*\nLet's start by implementing memoization for the expensive calculations in your ProductList component.</assistant>\n\n<reasoning>\nThe assistant used the todo 一覧を取得します because:\n1. First, the assistant examined the codebase to identify specific performance Issue\n2. Based on this analysis, it identified multiple optimization opportunities\n3. Performance optimization is a non-trivial task requiring multiple steps\n4. The todo 一覧を取得します helps methodically track improvements across 差分erent components\n5. This systematic approach ensures all performance bottlenecks are addressed\n</reasoning>\n</例>\n\n## 例 of When NOT to Use the Todo 一覧を取得します\n\n<例>\nUser: How do I print 'Hello World' in Python?\nAssistant: In Python, you can print \"Hello World\" with this simple code:\n\npython\nprint(\"Hello World\")\n\nThis will 出力 the text \"Hello World\" to the console when executed.</assistant>\n\n<reasoning>\nThe assistant did not use the todo 一覧を取得します because this is a single, trivial task that can be completed in one step. There's no need to track multiple tasks or steps for such a straightforward request.\n</reasoning>\n</例>\n\n<例>\nUser: What does the git status コマンド do?\nAssistant: The git status コマンド shows the current state of your working ディレクトリ and staging area. It displays which changes have been staged, which haven't, and which ファイル aren't being tracked by Git. This is a fundamental コマンド for understanding the current state of your リポジトリ before making コミット.\n\n<reasoning>\nThe assistant did not use the todo 一覧を取得します because this is an informational request with no actual coding task to complete. The user is simply asking for an explanation, not for the assistant to perform multiple steps or tasks.\n</reasoning>\n</例>\n\n<例>\nUser: Can you add a comment to the calculateTotal function to explain what it does?\nAssistant: Sure, let me add a comment to the calculateTotal function to explain what it does.\n* Uses the Edit ツール to add a comment to the calculateTotal function *\n\n<reasoning>\nThe assistant did not use the todo 一覧を取得します because this is a single, straightforward task confined to one location in the code. Adding a comment doesn't require tracking multiple steps or systematic organization.\n</reasoning>\n</例>\n\n<例>\nUser: Run npm install for me and tell me what happens.\nAssistant: I'll run the npm install コマンド for you.\n\n*実行します: npm install*\n\nThe コマンド completed successfully. Here's the 出力:\n[出力 of npm install コマンド]\n\nAll dependencies have been installed according to your package.json ファイル.\n\n<reasoning>\nThe assistant did not use the todo 一覧を取得します because this is a single コマンド execution with immediate 結果. There are no multiple steps to track or organize, making the todo 一覧を取得します unnecessary for this straightforward task.\n</reasoning>\n</例>\n\n## Task States and Management\n\n1. **Task States**: Use these states to track progress:\n   - pending: Task not yet started\n   - in_progress: Currently working on (limit to ONE task at a time)\n   - completed: Task finished successfully\n\n2. **Task Management**:\n   - 更新します task status in real-time as you work\n   - Mark tasks complete IMMEDIATELY after finishing (don't batch completions)\n   - Only have ONE task in_progress at any time\n   - Complete current tasks before starting new ones\n   - Remove tasks that are no longer relevant from the 一覧を取得します entirely\n\n3. **Task Completion Requirements**:\n   - ONLY mark a task as completed when you have FULLY accomplished it\n   - If you encounter エラー, blockers, or cannot finish, keep the task as in_progress\n   - When blocked, 作成します a new task describing what needs to be resolved\n   - Never mark a task as completed if:\n     - Tests are failing\n     - Implementation is partial\n     - You encountered unresolved エラー\n     - You couldn't find necessary ファイル or dependencies\n\n4. **Task Breakdown**:\n   - 作成します specific, actionable items\n   - Break complex tasks into smaller, manageable steps\n   - Use clear, descriptive task names\n\nWhen in doubt, use this ツール. Being proactive with task management demonstrates attentiveness and ensures you complete all requirements successfully.\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "todos": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "content": {
                  "type": "string",
                  "minLength": 1
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "pending",
                    "in_progress",
                    "completed"
                  ]
                },
                "id": {
                  "type": "string"
                }
              },
              "required": [
                "content",
                "status",
                "id"
              ],
              "additionalProperties": false
            },
            "description": "The updated todo 一覧を取得します"
          }
        },
        "required": [
          "todos"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "WebSearch",
      "description": "\n- Allows Claude to 検索します the web and use the 結果 to inform responses\n- Provides up-to-date information for current events and recent data\n- 返します 検索します 結果 information formatted as 検索します 結果 blocks\n- Use this ツール for accessing information beyond Claude's knowledge cutoff\n- 検索します are performed automatically within a single API call\n\nUsage notes:\n  - Domain filtering is supported to include or block specific websites\n  - Web 検索します is only available in the US\n  - Account for \"Today's date\" in <env>. For 例, if <env> says \"Today's date: 2025-07-01\", and the user wants the latest docs, do not use 2024 in the 検索します クエリ. Use 2025.\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "minLength": 2,
            "description": "The 検索します クエリ to use"
          },
          "allowed_domains": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Only include 検索します 結果 from these domains"
          },
          "blocked_domains": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Never include 検索します 結果 from these domains"
          }
        },
        "required": [
          "query"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "BashOutput",
      "description": "\n- Retrieves 出力 from a running or completed background bash shell\n- Takes a shell_id パラメータ identifying the shell\n- Always 返します only new 出力 since the last 確認します\n- 返します stdout and stderr 出力 along with shell status\n- Supports optional regex filtering to show only lines matching a pattern\n- Use this ツール when you need to monitor or 確認します the 出力 of a long-running shell\n- Shell IDs can be found using the /bashes コマンド\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "bash_id": {
            "type": "string",
            "description": "The ID of the background shell to retrieve 出力 from"
          },
          "filter": {
            "type": "string",
            "description": "Optional regular expression to フィルタします the 出力 lines. Only lines matching this regex will be included in the 結果. Any lines that do not match will no longer be available to 読み取ります."
          }
        },
        "required": [
          "bash_id"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    },
    {
      "name": "KillBash",
      "description": "\n- Kills a running background bash shell by its ID\n- Takes a shell_id パラメータ identifying the shell to kill\n- 返します a success or failure status \n- Use this ツール when you need to terminate a long-running shell\n- Shell IDs can be found using the /bashes コマンド\n",
      "input_schema": {
        "type": "object",
        "properties": {
          "shell_id": {
            "type": "string",
            "description": "The ID of the background shell to kill"
          }
        },
        "required": [
          "shell_id"
        ],
        "additionalProperties": false,
        "$schema": "http://json-schema.org/draft-07/schema#"
      }
    }
  ]
}
